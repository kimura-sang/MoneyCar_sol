  Аудит смарт контракта MoneyCar

====================================================================================================

-------*******###### Расположение контракта ######*******-------
Смарт контакт MoneyCar был прислан в сети Telegram.

-------*******###### Описание работы ######*******-------
Децентрализованная инвестиционно-краудфандинговая платформа воплощена в смарт-контракте, предназначенном
для распределения входящих переводов среди участников по разработанному алгоритму.
Для работы проекта предоставляется сайт, выполняющий функцию интерфейса.
Логика смарт - контракта работает по принципу реферального дерева: формирования структуры из реферов, команды.
Проект состоит из 3 циклов с одинаковым алгоритмом и разными суммами входа. После заполнения одного цикла
Участник переходит на следующий цикл.
После завершения 3 циклов всё начинается сначала, с такой же сформированной командой.
Пользователь одновременно регистрируется и отправляет 0.05 BNB на контракт. Далее контракт сам, автоматически,
распределяет сумму его вышестоящим партнерам.
Для получения дохода, пользователю необходимо самому искать партнёров, чтобы они указывали его id
при регистрации в смарт-контракте.

В проекте используется такое понятие, как Клон. Клон - пользователь с адресом кошелька, равным нолю.
Если при распределении прибыли такому пользователю попадают средства, то запускается следующий процесс:
- если количество средств больше, чем величина "price", то излишек отправляется на адрес "_clnWithdraw",
а остаток, т.е. величина "price" отправляется на адрес "_creator"
- если количество средств меньше или равно значению "price", то они отправляются на адрес "_creator"
С кошелька "_creator" можно запустить создание нового Клона - функция "createCln()". Но есть следующее
ограничение - в проекте должно быть не меньше 156 пользователей. Дальше этот процесс можно постоянно повторять.
При создании Клона у пользователя с ИД 1 меняется величина "last_row" на текущюю строку Клона.
Значение величины "last_row" в функции "findFreePlace()" используется при поиске свободного места для нового пользователя.

При распределении прибыли, если средства попадают на пользователя с ИД 1, происходит следующее:
- по 20% от величины распределяются на кошельки пользователей с ИД 2 и ИД 3
- по 10% от величины распределяются на кошельки пользователей с ИД 4 и ИД 5
- 10% распределяются так (по 22% от этой величины отправляются на 3 кошелька "externalAddresses" и
оставшаяся сумма на кошелек пользователя с ИД 6)
Пользователи с ИД 2 - ИД 6 создаются "_owner" с помощью функции "setInitial()"
Кошельки "externalAddresses" задаются "_owner" с помощью функции "setExternal()"

Для начала работы проекта необходимо выполнить:
setExternal(), setInitial(), setFirstClones()

Функция "_upgrade()" - позволяет изменить цикл пользователя.
Это единственная возможность для изменения цикла пользователя.
На запуск этой функции есть ограничение - на предыдущем цикле у пользователя должно быть 3905 партнеров.
Увеличивает число партнеров регистрация нового пользователя, запуск _upgrade()" и "createCln()".
Вызов функции "_upgrade() завязывается на создателе. Сам пользователь не может перейти на следующий цикл.
Необходимо рассмотреть возможность вызова "_upgrade() самим пользователем для осуществления принципа децентрализации.
В противном случае будет очень трудоемко регулярно отслеживать данные тысяч пользователей для смены их цикла.
К тому же эта процедура требует оплаты газа из кошелька организаторов проекта.
------------------------------------------------------------------------------------------------------------
Описание функций смарт контракта:
_register() - (любой пользователь) - функция для входа нового пользователя в проект. Стоимость входа равна значению,
   возвращаемому функцией "getPrice()". По умолчанию это 0.05 BNB
withdraw() - (любой пользователь) - может вызвать любой пользователь для снятия своих средств с баланса контракта.

_upgrade() - (только _creator) - позволяет сделать обновление данных пользователя по его ИД.
createCln() - (только _creator) - позволяет создать клона .

owner() - (любой) - возвращает адрес кошелька владельца контракта
getUserData() - (любой) - возвращает основные числовые параметры пользователя проекта (9 шт.)
showPartnersByLevel() - (любой) - по ИД пользователя возвращает уровни его партнеров
getMatrix() - (любой) - по ИД пользователя возвращает 3905 ИД пользователей. ИД выбираются со следующих
пяти строк за строкой пользователя, на которой он сейчас находится.

findFreePlace() - (любой) - по ИД пользователя возвращает 3 значения:
 - ближайшая свободная строка
 - ближайшая свободный столбец
 - ближайшее свободное место в строке
findUpline() - (любой) - по номеру столбца "x" возвращает число, равное "(x-1)/5 + 1"
getUplines() - (любой) - по ИД пользователя возвращает 5 ИД пользователей, находящихся на том же столбце,
но строками, каждый раз ниже на 1.
getPrice() - (любой) Просмотр базовой цены для входа в проект

setPrice() - (только _owner) Изменение базовой цены для входа в проект
setExternal() - (только _owner) - устанавливает адреса 3-х кошельков, которые используются для распределения
прибыли с пользователя у которого ИД = 6.
setInitial() - (только _owner) - регистрирует 5 кошельков пользователей, находящихся во 2-ом ряду.
setFirstClones() - (только _owner) - создает 25 пользователей в 3 ряду, с адресами кошельков, равными 0.
Так называемых Клонов.
setCreator() - (только _owner) - позволяет изменить адрес "_creator"
setWithdrawal() - (только _owner) - позволяет изменить адрес "_clnWithdraw". На этот адрес отправляется разница
между общим количеством заработанного BNB и значением величины "price". BNB в количестве "price" отправляется на адрес "_creator"
transferOwnership() - (только _owner) - позволяет изменить адрес "_owner"


-------*******###### Классификация найденных уязвимостей ######*******-------
•	CRITICAL: Ошибки, приводящие к краже BNB или токенов, блокировке доступа к фондам или любой другой потере BNB / токенов,
    которые должны быть переданы любой стороне (например, дивиденды) или получены от нее.

•	MIDDLE: Ошибки, которые могут привести к сбою работы контракта.
    Дальнейшее восстановление возможно только путем ручного изменения состояния контракта или его замены.

•	WARNINGS: Ошибки, которые могут нарушить предполагаемую логику контракта или подвергнуть его DoS-атакам и т.д.

•	COMMENTS: Другие проблемы и рекомендации, сообщенные для команды.

====================================================================================================

-------*******###### CRITICAL ######*******-------

#### 1. Блокировка работы всего контракта
##### Description
На строках 494, 526, 574, если получателем окажется контракт, то вся логика проекта может блокироваться.
Это произойдет в случае, если в "fallback()"-функции будет стоять "revert()".
Известны случаи, когда из-за такой ошибки блокировалась работа уже запущенных проектов.
##### Recommendation
Необходимо убрать передачу активов с баланса контракта на кошелек пользователя с помощью функции "transfer()".
Если передача, будет происходить путем вызова "call()", необходимо добавить защиту от Reentrancy атак.


#### 2. Невозможность обновления цикла и как результат - блокировка работы проекта.
##### Description
На строке 563 идёт запись в переменную "locked". При добавлении единицы к "users[_userId].cycle", равном два,
из-за mapping "userLockedRev" виртуальная машина выбрасывает ошибку "index out of range".
Так как максимальный индекс от цикла пользователя равен двум.
##### Recommendation
В строке 563 и 577 изменить "users[_userId].cycle" на "userCycle-1".

-------*******###### MIDDLE ######*******-------

#### 1. Возможность изменения участников и клонов и как результат - блокировка работы проекта.
##### Description
Первые пять партнёров и (при необходимости) 25 клонов заполняются owner'ом. В дальнейшем он способен изменить эти данные,
просто заново вызвав нужные функции.
##### Recommendation
Добавить проверку с "require" на существование "id" первого пользователя в заполняемом ряду, можно через mapping "globalPlaces".

#### 2. Возможность проведения Reentrancy атаки
##### Description
При передаче эфира с баланса контракта следует учитывать возможность Reentrancy атаки.
Сейчас при использовании функции "transfer()" используется 2300 единиц газа, но очередной форк сети Ethereum может изменить
значение этого показателя в большую сторону. В этом случае принимающая сторона может использовать дополнительную логику в fallback-функции,
приводящую к атаке типа  Reentrancy.
##### Recommendation
1. В функции "withdraw" c самого начала необходимо объявить внутреннюю переменную, равную "balances[msg.sender]", используя
   её в строках: 259-261. Также необходимо переставить код на строке 262 сразу же после объявления внутренней переменной.
2. Строку 577 поставить сразу после 563 (возможность атаки в данном случае появляется после учитывания
   ошибки №2 - "Невозможность обновления цикла и как результат - блокировка работы проекта").
3. Приравнять "amount.sub(price)" к переменной сразу после 582 строки, заменив "amount.sub(price)" на строке 584.
   Также необходимо переставить строку 585 сразу после 583.


-------*******###### WARNINGS ######*******-------

#### 1.  При записи события передаются неверные значения
##### Description
На строке 133 производится запись события "Register".
Но второй параметр в этом событии "_userId" равен 0, хотя должен быть равен 1.
##### Recommendation
Перед записью события увеличить значение переменной "lastUserId" на 1.

#### 2. Выполнение не нужной логики при определенных условиях
##### Description
Иногда программист забывает сделать проверку определенных условий и выполняются какие-либо действия не приводящие
к значимому результату, т.е по сути дела ничего не меняется.
Такой код наблюдается на строках 484 - 504, если значение переменной "amount" равно 0.
##### Recommendation
В условии на 484 строке следует добавить проверку  "&& amount > 0".

#### 3. Нет проверки значения, возвращаемого функцией
##### Description
На строке 591 объявлено, что функция "createCln()" должна возвращать булеву переменную.
Но по факту этого не происходит.
##### Recommendation
Необходимо проверять, возвращает ли функция объявленное значение. Либо убрать "returns (bool)" со строки 591.

#### 4. Сбой работы всего контракта из-за неверного присваивания переменной
##### Description
Происходит неверное присваивание "id" при регистрации пользователя, если не вызвана функция "setFirstClones()".
На строках 167-188 в функции "setInitial()" создаются 5 новых пользователей. Но переменная "lastUserId" не увеличивается.
На строках 115-137 в конструкторе также создается новый пользователь, но значение переменной "lastUserId" равно 0.
В то же время идет увеличение этой переменной при регистрации нового пользователя на строке 365 и при создании новых
клонов на строке 210.
##### Recommendation
В конструкторе и функции "setInitial()" необходимо добавить изменение переменной "lastUserId".

-------*******###### COMMENTS ######*******-------

#### 1. Завязка обновления цикла пользователя на создателе
##### Description
Вызов функции "_upgrade() завязывается на создателе. Сам пользователь не может перейти на следующий цикл.
##### Recommendation
Рассмотреть возможность вызова "_upgrade() самим пользователем для осуществления принципа децентрализации.

#### 2. Дублирование кода
##### Description
Дублирование кода - плохая практика в программировании, которая приводит к трудноуловимым ошибкам.
Для избежания этой проблемы необходимо повторяющиеся участки кода переносить в отдельные методы или функции.
В этом проекте такой код наблюдается на строках: 487 - 496, 519 - 528 и 567 - 576.
Также происходит дублирование функции "getUplines()" со строк 401-409 на строки 416 - 424.
##### Recommendation
Рекомендуется сделать рефакторинг исходного кода.

#### 3. Не корректные названия для функций, событий, переменных и т.д.
##### Description
Для лучшего восприятия кода следует давать названия переменным, функциям и их аргументам, которые наилучшим образом
иллюстрируют их назначение. Не верное название часто вводит в заблуждение человека, изучающего код.
- На строке 102 в событии "UplinesFound" неверное объявление: на самом деле аргументами события являются индексы аплайнов.
   Необходимо заменить "level..." в аргументах на "id...".
- На строке 78 заменить имя массива "cyclePercentage" на "levelPercentage"
- На строке 394 изменить название функции "findUpline()" на "findUplineCol()"
##### Recommendation
Рекомендуется сделать рефакторинг исходного кода.

#### 4. Часть названий функций с большой буквы, а часть с маленькой
##### Description
На строках 456, 536 название функций даны с большой буквы.
Но по "code style" не рекомендуется давать названия функциям с большой буквы.
С описанием "code style" можно ознакомиться здесь: https://docs.soliditylang.org/en/latest/style-guide.html.
##### Recommendation
Рекомендуется сделать рефакторинг исходного кода.


-------*******###### Выводы ######*******-------
В ходе аудита было найдено много ошибок различных уровней значимости.
В том числе было найдено и несколько критических ошибок, которые приводят к потере активов.

Необходимо децентрализовать смену цикла у пользователей.
В противном случае будет очень трудоемко регулярно отслеживать данные тысяч пользователей для смены их цикла.
К тому же эта процедура требует оплаты газа из кошелька организаторов проекта.
Лучше, если это будут делать и оплачивать сами участники проекта.

Перед установкой смарт контракта в Главную сеть необходимо сделать исправление найденных ошибок.

